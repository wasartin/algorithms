/**
 * @author Will Sartin & Josh Ramon
 */
import java.util.ArrayList;

public class Intervals {
	
	private int currID = 0;
	private RBTree rbtree;
	private ArrayList<Interval> intervalList; //the id of an interval can now just be it's position, but can't alter positions
	private Interval deleted;
	
	//Made public for testing
	/**
	 * Sub class that is the interval object (Two endpoints)
	 * @author Will
	 *
	 */
	public class Interval {
		private Endpoint start;
		private Endpoint end;
		
		public Interval(int start, int end) {
			this.start = new Endpoint(start, Position.LEFT);
			this.end = new Endpoint(end, Position.RIGHT);
		}
		
		public Interval(Endpoint e1, Endpoint e2) {
			this.start = e1;
			this.end = e2;
		}
		
		public Endpoint getStart() {
			return this.start;
		}
		
		public Endpoint getEnd() {
			return this.end;
		}
		
		@Override
		public String toString() {
			return "{Start:" + this.getStart().toString() + " End:" + this.getEnd().toString() + "}";
		}
	}
	
	/**
	 * @Required
	 */
	public Intervals() {
		rbtree = new RBTree();
		intervalList = new ArrayList<>();
		deleted = new Interval(new Endpoint(0, Position.NIL), new Endpoint(0, Position.NIL));
	}
	
	/**
	 * @Required
	 * Adds the interval with left endpoint a and right
	 * endpoint b to the collection of intervals. Each newly inserted interval must be assigned an
	 * ID. The IDs should be consecutive; that is, the ID of the interval inserted on the ith call of
	 * this method should be i. For example if intervalInsert is called successively to insert
	 * intervals [5, 7], [4, 9], [1, 8], then the IDs of these intervals should be 1, 2, 3, respectively.
	 * These IDs are permanent for the respective intervals. Keep track of the IDs, as multiple
	 * intervals that have the same endpoints on both sides can be added. intervalInsert
	 * should run in O(log n) time
	 * @param firstPoint
	 * @param secondPoint
	 */
	public void intervalInsert(int a, int b) throws IllegalArgumentException {
		if(a > b) {
			throw new IllegalArgumentException("The first point must precede the second point");
		}
		
		Interval toAdd = new Interval(a, b);
		intervalList.add(toAdd);
		updateRBTree(toAdd);
	}
	
	private void updateRBTree(Interval toAdd) {
		Node newNodeOne = new Node(toAdd.getStart());
		Node newNodeTwo = new Node(toAdd.getEnd());
		rbtree.RBInsert(newNodeOne);
		rbtree.RBInsert(newNodeTwo);
	}

	private Interval getInterval(int position) {
		if(position < 1) {
			throw new IllegalArgumentException("Interval starts at 1, You selected: " + position);
		}
		if(position > intervalList.size()) {
			throw new IllegalArgumentException("The position you selected (" + position + "), is larger than the size of current intervals:" + this.getID());
		}
		Interval found = intervalList.get(position - 1);
		Endpoint a = found.getStart();
		Endpoint b = found.getEnd();
		if(a.getPValue() == Position.NIL || b.getPValue() == Position.NIL) {
			throw new IllegalArgumentException("The selected ID:" + position + ", has already been deleted");
		}
		//should check if Nil node
		return found;
	}
	
	/** EXTRA CREDIT
	 * boolean intervalDelete(int intervalID): Deletes the interval whose ID (generated by intervalInsert) is intervalID. 
	 * Returns true if deletion was successful. This
	 * method should run in O(log n) time.
	 * Note. The intervalDelete method is optional; that is, you are not required
	 * to implement it. However, your code must provide an intervalDelete method
	 * even if you choose not to implement interval deletion. If you do not implement
	 * deletion, the intervalDelete method should consist of just one line that returns
	 * false.
	 * @param intervalID
	 * @return
	 */
	public boolean intervalDelete(int intervalID) {
		Interval selected = null;
		try {
			selected = getInterval(intervalID);
		}catch(Exception e){
			return false;
		}
		Node leftPointToDelete = rbtree.searchIterative(selected.getStart().getValue());
		Node rightPointToDelete = rbtree.searchIterative(selected.getEnd().getValue());
		if(leftPointToDelete.isNilNode() || rightPointToDelete.isNilNode()) {
			return false;
		}
		this.rbtree.RBDelete(leftPointToDelete);
		this.rbtree.RBDelete(rightPointToDelete);
		intervalList.set(intervalID - 1, deleted);
		return true;
	}
	
	/**
	 * @Required
	 * Finds the endpoint that has maximum overlap and returns its value. This
	 * method should run in constant time.
	 * @return
	 */
	public int findPOM() {
		if(rbtree.getRoot().isNilNode()) {
			return 0;
		}
		return rbtree.getRoot().getEmax().getValue();
	}
	
	/**
	 * @Required
	 * Returns the red-black tree used, which is an object of type RBTree.
	 * @return
	 */
	public RBTree getRBTree() {
		return rbtree;
	}
	
	public int getID() {
		return this.intervalList.size() + 1;
	}
}
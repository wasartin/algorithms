package main.java;

import java.util.ArrayList;

public class Intervals {
	
	private int currID = 0;//Not sure how to handle a 'global' counter
	private RBTree rbtree;
	//Keep an arrayList of intervals? idk how else to do the id thing
	private ArrayList<Interval> intervalList; //the id of an interval can now just be it's position
	
	//Made public for testing
	public class Interval {
		private int left;
		private int right;
		
		public Interval(int left, int right) {
			this.left = left;
			this.right = right;
		}
		
		public Interval(Endpoint e1, Endpoint e2) {
			this.left = e1.getValue();
			this.right = e2.getValue();
		}
		
		public int getLeft() {
			return this.left;
		}
		
		public int getRight() {
			return this.right;
		}
	}
	
	public Intervals() {
		rbtree = new RBTree();
		intervalList = new ArrayList<>();
	}
	
	/**
	 * Adds the interval with left endpoint a and right
	 * endpoint b to the collection of intervals. Each newly inserted interval must be assigned an
	 * ID. The IDs should be consecutive; that is, the ID of the interval inserted on the ith call of
	 * this method should be i. For example if intervalInsert is called successively to insert
	 * intervals [5, 7], [4, 9], [1, 8], then the IDs of these intervals should be 1, 2, 3, respectively.
	 * These IDs are permanent for the respective intervals. Keep track of the IDs, as multiple
	 * intervals that have the same endpoints on both sides can be added. intervalInsert
	 * should run in O(log n) time
	 * @param firstPoint
	 * @param secondPoint
	 */
	public void intervalInsert(int a, int b) throws IllegalArgumentException {
		if(a > b) {
			throw new IllegalArgumentException("The first point must precede the second point");
		}
		//Will this just be inserting into the RBTree?
		
		//Make ints into endpoints and add into interval list
		int left = 1;
		int right = -1;
		Endpoint start = new Endpoint(a, left);
		Endpoint end = new Endpoint(b, right);
		intervalList.add(new Interval(start, end)); 
		
		//Turn endpoint into nodes so they can be inserted into a tree
		Node newNodeA = new Node(start);
		Node newNodeB = new Node(end);
		
		//Insert nodes into RBT
		rbtree.RBInsert(newNodeA);
		rbtree.RBInsert(newNodeB);
	}
	
	
	
	public Interval getInterval(int position) {
		if(position < 1) {
			throw new IllegalArgumentException("Interval starts at 1");
		}
		else if(position > intervalList.size()) {
			throw new IllegalArgumentException("The position you selected is larger than the size of current intervals: " + intervalList.size());
		}
		return intervalList.get(position - 1);
	}
	
	
	
	/** EXTRA CREDIT
	 * boolean intervalDelete(int intervalID): Deletes the interval whose ID (generated by intervalInsert) is intervalID. Returns true if deletion was successful. This
	 * method should run in O(log n) time.
	 * Note. The intervalDelete method is optional; that is, you are not required
	 * to implement it. However, your code must provide an intervalDelete method
	 * even if you choose not to implement interval deletion. If you do not implement
	 * deletion, the intervalDelete method should consist of just one line that returns
	 * false.
	 * @param intervalID
	 * @return
	 */
	public boolean intervalDelete(int intervalID) {
		//TODO
		return false;
	}
	
	/**
	 * Finds the endpoint that has maximum overlap and returns its value. This
	 * method should run in constant time.
	 * @return
	 */
	public int findPOM() {
		if(rbtree.getSize() > 0) {
			return -1;
		}
		return rbtree.getRoot().getEmax().getValue();
	}
	
	/**
	 * Returns the red-black tree used, which is an object of type RBTree.
	 * @return
	 */
	public RBTree getRBTree() {
		return rbtree;
	}
	
	
	/**TODO: put this in the test class
	 * This is a suggested way on how to add intervals and call POM()
	 * 
	 * @param args
	 */
	public static void main(String [] args) {
		int points[][] = {{0, 4}, {1, 6}, {3, 9}, {7, 11}};
		Intervals intv = new Intervals();
		
		for(int i=0; i<points.length; i++) {
			//System.out.println("Inserting: "+ Arrays.toString(points[i]));
			intv.intervalInsert(points[i][0], points[i][1]);
		}
		System.out.println("POM is: "+ intv.findPOM()); //Should return 3.
	}
	
}
